### 组件通信

#### 概念

组件通信就是<span style="color:red">组件之间的数据传递</span>，根据组件嵌套关系的不同，有不同的通信方法。

#### 分类

##### 1.父子通信
<span style="color:orange; font-size：25px">（1）父传子</span>

- 一 自闭和写法
```jsX
//子组件，组件就是首字母大写的函数
//要让子组件接收数据-子组件需要通过props参数接收数据 
function Son(props) {
  console.log(props);//{name:'jack}
  return <div>this is son,{props.name}</div>
}

function App() {
  //父组件的数据
  const name = 'jack'
  return (
    <div className="App">
      {/* 在子组件绑定属性*/}
      <Son name={name} />
      {/* 在 JSX 中，以这种形式
      <ComponentName propName={value}>
      来为组件设置属性是一种标准的语法格式。
      其中，propName是属性名，{value}是属性值*/}
    </div >
  );
}
```

><Son name={name} />就是父组件向Son子组件传递一个名为name的属性，等号右边的name是父组件作用域内的变量，它的值会被赋给子组件的name属性，子组件可以通过props.name来访问这个值。

- 二 成对标签写法
```jsX
function Son(props) {
  console.log(props);//{children}
  return <div>this is son,{props.children}</div>//this is son,this is span
}

function App() {
  return (
    <div className="App">
      {/* 若使用成对标签的写法，默认创建children属性，并将其加入其中 */}
      <Son>
        <span>this is span</span>
      </Son>
    </div >
  );
}
```

###### props说明：
<span style="color:red">1.props可以传递任意的数据：</span>

```jsX
function Son(props) {
  console.log(props);//{name: 'jack', age: 18, child: {…}}
  return <div>this is son,{props.name},jsX:{props.child}</div>
}

function App() {
  const name = 'jack'
  return (
    <div className="App">
      {/* 在子组件绑定属性*/}
      <Son
        name={name}
        age={18}
        child={<span>this is span</span>} />
    </div >
  );
}
```

2.Props是只读对象：
子组件<span style="color:red">只能读取props中的数据</span>，不能直接修改，
父组件的数据只能由父组件修改。

<span style="color:orange; font-size：25px">（2）子传父</span>

```jsX
import { useState } from 'react'
//子传父：儿子调用父亲的函数，并传递参数
function Son({ onMessage }) {
  // 儿子用来接函数时，解构赋值，直接把函数传过来
  // 儿子给调用过来的函数传递参数：
  const sonMsg = 'this a span'
  return <button onClick={() => onMessage(sonMsg)}>dianji</button>
}

function App() {
  const [msg, setMsg] = useState('')
  const newMessage = (msg) => {
    console.log(msg);
    setMsg(msg)
  }
  return (
    <div className="App">
      {/* 将父亲中的函数传给儿子 */}
      {/* 传递函数时，一般属性名最前面写on */}
      <Son onMessage={newMessage} />
      {/* 只有在组件的最外层return中，才能在页面中渲染 */}
      {/* 下面语句是：如果传过来的msg非空，那么实现后面的渲染*/}
      {msg && <div>this is div,{msg}</div>}
    </div >
  );
}

export default App;
```

##### 2.兄弟通信

<span style="color:orange; font-size:17px">使用状态提升实现兄弟组件通信：</span>
<span style="color:blue; font-size:15px">实现思路：借助"状态提升"机制，通过父组件进行兄弟组件之间的数据传递</span>
<span style="font-size:14px">1.A组件先通过子传父的方式将数据传递给父组件App
2.App拿到数据后再通过父传子的方式将数据传递给B组件（用到状态变量）</span>


```jsx
import { useState } from 'react'
//使用状态提升实现兄弟组件通信：

function A({ ongetMsg }) {
  const newmsg = 'this is newmsg'
  return (
    // 当点击时，就会实现参数传递，才会有接下来关于B组件中被传递过去的参数
    <button onClick={() => { ongetMsg(newmsg) }}>dianji</button>
  )
}

function B({ name }) {
  return (
    <div>this B,{name}</div>
  )
}

function App() {
  const [message, setMessage] = useState('')
  const getMsg = (msg) => {
    // 现在要在getMsg函数外面使用这个传递过来的参数，必须用状态变量
    console.log(msg);//'this is newmsg'
    setMessage(msg)
  }
  return (
    <div className="App">
      {/* //1.子传父-A调用App组件中的函数，传递参数  */}
      <A ongetMsg={getMsg} />

      {/* // 2.父传子-App组件将A传递过来的参数传递给B */}
      <B name={message} />
    </div >
  );
}

export default App;
```

##### 3.跨层通信

```jsx
// 1).import React, { useContext } from 'react'
// 2):
import { creatContext, useContext } from 'react'

//使用context机制跨层传递数据
//1.创建context对象
//2.将context对象使用Provider导入父组件中
//3.将context对象导入到子组件

// 1).const newContext = React.createContext('defaultValue')
// 2):
const newContext = creatContext()

function One() {
  return (
    // 这里假定Two组件是One的子组件,没什么意义，只是想表明如果想要实现跨层传递数据，
    // 可以不需要用props一层层传递，可以直接用context机制达成目的
    <Two />
  )
}

function Two() {
  // 使用useContext钩子获取Context中的数据
  const contextValue = useContext(newContext)
  return (
    <div>
      {/* 渲染从Context中获取的数据 */}
      <p>{contextValue}</p>
    </div>
  )
}

function App() {
  // 创建需要传递的参数
  const msg = 'this is msg'
  return (
    // 使用Provider包裹子组件，并通过value属性传递共享数据
    <newContext.Provider value={msg}>
      {/* 这里可以放置子组件 */}
      <One />
    </newContext.Provider>
  );
}

export default App;
```
